<!DOCTYPE html>
<html>
<head>
    <title>Mapbox GL JS debug page</title>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel='stylesheet' href='../dist/mapbox-gl.css' />
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>

<body>
<div id='map'></div>
<script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>

<script type="module">

    const vertexShader = `
    attribute vec3 a_pos_ecef;
    attribute vec3 a_pos_merc;
  varying vec2 vUv;
  varying mat4 vPosition;
    uniform mat4 u_globeToMercMatrix;
    uniform float u_globeToMercatorTransition;
    uniform vec2 u_centerInMerc;
    uniform float u_pixelsPerMeterRatio;


  uniform mat4 u_projection;
        uniform mat4 u_mercatorProjection;
        uniform float u_isGlobe;
        uniform float u_transition;
        vec4 project_custom_layer(vec3 pos_merc, vec3 pos_ecef, mat4 instanceMatrix) {
            if (u_isGlobe == 1.0) {
                vec4 projected_pos = instanceMatrix * u_projection * vec4(pos_ecef, 1.0);
                projected_pos /= projected_pos.w;
                if (u_transition > 0.0) {
                    vec4 mercator = u_mercatorProjection * vec4(pos_merc, 1.0);
                    mercator /= mercator.w;
                    projected_pos = mix(projected_pos, mercator, u_transition);
                }
                return projected_pos;
            } else {
                return instanceMatrix * u_projection * vec4(pos_merc, 1.0);
            }
        }

void main() {
    vUv = uv;
    vec4 projectedPosition;

    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

    #ifdef USE_INSTANCING
        vec4 p = projectionMatrix * vec4(a_pos_ecef, 1.);
        p /= p.w;
        if (u_globeToMercatorTransition > 0.) {
            vec4 merc = vec4(a_pos_merc, 1.);
            merc.xy = (merc.xy - u_centerInMerc) * u_pixelsPerMeterRatio + u_centerInMerc;
            merc.z *= u_pixelsPerMeterRatio;
            merc = projectionMatrix * merc;
            merc /= merc.w;
            p = mix(p, merc, u_globeToMercatorTransition);
        }
        gl_PointSize = 30.;
        gl_Position = p;

        return;

    float scale = -exp((projectionMatrix * vec4(1.0,1.0,1.0 , 1.0 )).z / 50000.0 );

    mat4 sPos = mat4(vec4(scale,0.0,0.0,0.0),
                     vec4(0.0,scale,0.0,0.0),
                     vec4(0.0,0.0,scale,0.0),
                     vec4(0.0,0.0,0.0,1.0));

    vPosition = instanceMatrix * sPos;
    projectedPosition = project_custom_layer(a_pos_merc, a_pos_ecef,instanceMatrix);


    gl_Position = projectedPosition;

    #endif

}
`;

    // gl_Position = projectionMatrix * vPosition * mvPosition;
    const fragmentShader = `
    precision highp float;
    uniform sampler2D map;
    varying vec2 vUv;

    void main() {
       gl_FragColor = texture2D( map, vUv );
    }
`;


    const planeSize = 1;
    const planeBufferGeometry = new THREE.PlaneBufferGeometry(planeSize, planeSize, 2, 2);

    const material = new THREE.MeshBasicMaterial(
        {
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false,
            transparent: true,
            color: new THREE.Color('white'),
        }
    ) || new THREE.ShaderMaterial({
        side: THREE.DoubleSide,
        depthTest: false,
        depthWrite: false,
        transparent: true,
        //vertexShader,
        // fragmentShader,
    });

    const mapCenter = mapboxgl.MercatorCoordinate.fromLngLat([0, 0], 0);

    const Threejscustomlayer = {
        type:"custom",
        renderMode:"3d",
        id:"three-js",
        map:undefined,

        onAdd:function (map,gl) {
            this.map = map;
            const mapCanvas = map.getCanvas();
            this.scene = new THREE.Scene();

            const { x, y, z } = mapCenter;
            this.cameraTransform = new THREE.Matrix4().makeTranslation(x, y, z || 0);

            this.camera = new THREE.PerspectiveCamera(45, mapCanvas.width / mapCanvas.height, 0.1, 1000);

            this.renderer = new THREE.WebGLRenderer({
                canvas: mapCanvas,
                context: gl,
            });

            this.renderer.autoClear = false;

            const helper = new THREE.CameraHelper(this.camera);
            this.scene.add(helper);

        },
        render:function (gl, matrix, projection) {
            const projectionMatrix = new THREE.Matrix4().fromArray(matrix);
            if (this.map.transform.projection.name === 'globe') {
                const oldProjection = new THREE.Matrix4().fromArray(this.map.painter.transform.customLayerMatrix());
                const globeProjection = new THREE.Matrix4().fromArray(this.map.painter.transform.globeToMercatorMatrix());
console.log(oldProjection,globeProjection)
                this.camera.projectionMatrix =  globeProjection.multiply(projectionMatrix) || oldProjection.multiply(globeProjection);
            }else{
                this.camera.projectionMatrix = projectionMatrix.multiply(this.cameraTransform);

            }
            this.renderer.state.reset();
            this.renderer.render(this.scene, this.camera);
            this.map.triggerRepaint();
        },
    }


    const mapbox = new mapboxgl.Map({
        container: 'map',
        zoom: 3,
        center: [-122.4194, 37.7749],
        style: 'mapbox://styles/mapbox/dark-v11',
        projection: 'globe'
    });

    const clearInstancedMesh = () =>{
        const meshes = Threejscustomlayer.scene.children.filter(objects=>{
            return objects.isInstancedMesh;
        })
        meshes.forEach(mesh=>mesh.removeFromParent())
    }

    const createInstancedMesh = () =>{
        const quantity = 1;
        const mesh = new THREE.InstancedMesh(planeBufferGeometry, material, quantity);
        const isGlobe = Threejscustomlayer.map.transform.projection.name === 'globe';

        for(let i = 0 ; i < quantity ; i++){
            const matrix = new THREE.Matrix4();

            const coordinates = [-120, 40];
            const ECEFPosition = mapboxgl.LngLat.convert(coordinates).toEcef(0);
            const mercatorCoordinates = mapboxgl.MercatorCoordinate.fromLngLat(coordinates, 0);
            const {x,y,z} = mercatorCoordinates;
            const adjustedMercatorCoords = new THREE.Vector3(x - mapCenter.x, y - mapCenter.y, z || 0 - (mapCenter.z || 0));


            const dir = new THREE.Vector3().copy(isGlobe ? ECEFPosition : adjustedMercatorCoords);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);

            if(isGlobe){
                matrix.makeRotationFromQuaternion(quaternion);
            }

            matrix.scale(isGlobe ? new THREE.Vector3(10000,10000,10000) : new THREE.Vector3(0.01,0.01,0.01));
            matrix.setPosition(isGlobe ? ECEFPosition : adjustedMercatorCoords);

            const color = new THREE.Color("red")

            mesh.setMatrixAt(i,matrix);
            mesh.setColorAt(i,color);
        }

        mesh.needsUpdate = true;

        Threejscustomlayer.scene.add(mesh)
    }

    mapbox.on("load",()=>{
        mapbox.addLayer(Threejscustomlayer);

        mapbox.on("zoom",()=>{
            clearInstancedMesh();
            createInstancedMesh();
        })
    })

</script>
<script src='../dist/mapbox-gl.js'></script>
<script src='../debug/access_token_generated.js'></script>
<script>

</script>
</body>
</html>
